"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[5051],{44747:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"developer-guide/views","title":"Views and Projections","description":"The same data can be drawn differently to screen based on what projection method is used. deck.gl\'s view system defines how one or more cameras should be set up to look at your data objects. The default view used in deck.gl is the MapView, which implements the Web Mercator projection.","source":"@site/../docs/developer-guide/views.md","sourceDirName":"developer-guide","slug":"/developer-guide/views","permalink":"/docs/developer-guide/views","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/deck.gl/tree/master/website/../docs/developer-guide/views.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Coordinate Systems","permalink":"/docs/developer-guide/coordinate-systems"},"next":{"title":"Animations and Transitions","permalink":"/docs/developer-guide/animations-and-transitions"}}');var r=t(74848),a=t(28453),s=t(11470),o=t(19365);const l={},c="Views and Projections",d={},h=[{value:"View, View State and Viewport",id:"view-view-state-and-viewport",level:2},{value:"View",id:"view",level:3},{value:"View State",id:"view-state",level:3},{value:"Viewport",id:"viewport",level:3},{value:"Types of Views",id:"types-of-views",level:2},{value:"Examples",id:"examples",level:2},{value:"Using a View",id:"using-a-view",level:3},{value:"Using a View with View State",id:"using-a-view-with-view-state",level:3},{value:"Using Multiple Views",id:"using-multiple-views",level:3},{value:"Using Multiple Views with View States",id:"using-multiple-views-with-view-states",level:3},{value:"Rendering Layers in Multiple Views",id:"rendering-layers-in-multiple-views",level:3},{value:"Picking in Multiple Views",id:"picking-in-multiple-views",level:3},{value:"Auto-Positioning UI Components Behind Views",id:"auto-positioning-ui-components-behind-views",level:3},{value:"Performance Notes",id:"performance-notes",level:2}];function p(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"views-and-projections",children:"Views and Projections"})}),"\n",(0,r.jsxs)(n.p,{children:["The same data can be drawn differently to screen based on what projection method is used. deck.gl's view system defines how one or more cameras should be set up to look at your data objects. The default view used in deck.gl is the ",(0,r.jsx)(n.a,{href:"/docs/api-reference/core/map-view",children:"MapView"}),", which implements the ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Web_Mercator_projection",children:"Web Mercator projection"}),".\nThe view system is designed to be flexible and composable and can handle many different configurations such as side-by-side views, overlapping views etc. If you plan to work with non-geospatial data, or show more than a single standard viewport, it may be worth spending some time to get familiar with the ",(0,r.jsx)(n.code,{children:"View"})," API."]}),"\n",(0,r.jsx)(n.p,{children:"View classes enable applications to specify one or more rectangular viewports and control what should be rendered inside each view."}),"\n",(0,r.jsx)("table",{style:{border:0},align:"top",children:(0,r.jsx)("tbody",{children:(0,r.jsxs)("tr",{children:[(0,r.jsxs)("td",{style:{verticalAlign:"top"},children:[(0,r.jsx)("img",{height:"200",src:"https://raw.github.com/visgl/deck.gl-data/master/images/docs/minimap.gif"}),(0,r.jsx)("p",{children:(0,r.jsx)("i",{children:'A "minimap" app, implemented as two overlapping, partially synchronized MapViews'})})]}),(0,r.jsxs)("td",{style:{verticalAlign:"top"},children:[(0,r.jsx)("img",{height:"200",src:"https://raw.github.com/visgl/deck.gl-data/master/images/docs/first-person-view.gif"}),(0,r.jsx)("p",{children:(0,r.jsx)("i",{children:"A vehicle log rendered from the driver's perspective, implemented with FirstPersonView"})})]}),(0,r.jsxs)("td",{style:{verticalAlign:"top"},children:[(0,r.jsx)("img",{height:"200",src:"https://raw.github.com/visgl/deck.gl-data/master/images/docs/orthographic-view.gif"}),(0,r.jsx)("p",{children:(0,r.jsx)("i",{children:"A graph, implemented with OrthographicView"})})]})]})})}),"\n",(0,r.jsx)(n.h2,{id:"view-view-state-and-viewport",children:"View, View State and Viewport"}),"\n",(0,r.jsx)(n.h3,{id:"view",children:"View"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.a,{href:"/docs/api-reference/core/view",children:"View"})," instance defines the following information:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A unique ",(0,r.jsx)(n.code,{children:"id"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["The position and extent of the view on the canvas: ",(0,r.jsx)(n.code,{children:"x"}),", ",(0,r.jsx)(n.code,{children:"y"}),", ",(0,r.jsx)(n.code,{children:"width"}),", and ",(0,r.jsx)(n.code,{children:"height"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Certain camera parameters specifying how your data should be projected into this view, e.g. field of view, near/far planes, perspective vs. orthographic, etc."}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.a,{href:"/docs/api-reference/core/controller",children:"controller"})," to be used for this view. A controller listens to pointer events and touch gestures, and translates user input into changes in the view state. If enabled, the camera becomes interactive."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["To summarize, a ",(0,r.jsx)(n.code,{children:"View"}),' instance wraps the "hard configuration" of a camera. Once defined, it does not need to change frequently.']}),"\n",(0,r.jsx)(n.p,{children:"deck.gl allows multiple views to be specified, allowing the application to divide the screen into multiple similar or different views. These views can be synchronized or separately controlled by the user or the application."}),"\n",(0,r.jsx)(n.h3,{id:"view-state",children:"View State"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"View"})," instance must be used in combination with a ",(0,r.jsx)(n.code,{children:"viewState"})," object. As the name suggests, the object describes the state of a ",(0,r.jsx)(n.code,{children:"View"})," instance. The view state object defines the temporary properties of a view at runtime, like the camera position, orientation, zoom, etc. If the view is interactive, every time the user pans/rotates/zooms, the view state will be updated to reflect the change."]}),"\n",(0,r.jsxs)(n.p,{children:["To summarize, a ",(0,r.jsx)(n.code,{children:"viewState"}),' object describes the "real-time properties" of a camera. It may be updated continuously during interaction and/or transition.']}),"\n",(0,r.jsx)(n.h3,{id:"viewport",children:"Viewport"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.a,{href:"/docs/api-reference/core/viewport",children:"Viewport"}),' instance is the camera itself. It is "resolved" from a ',(0,r.jsx)(n.code,{children:"View"})," instance and its ",(0,r.jsx)(n.code,{children:"viewState"}),". It handles the mathematical operations such as coordinate projection/unprojection, the calculation of projection matrices, and other GLSL uniforms needed by the shaders."]}),"\n",(0,r.jsxs)(n.p,{children:["Whenever ",(0,r.jsx)(n.code,{children:"viewState"})," updates, the view creates a new viewport under the hood. Typically, the deck.gl user does not need to work with viewports directly. In certain use cases, the JavaScript functions offered by a ",(0,r.jsx)(n.code,{children:"Viewport"})," instance can be handy for projecting and unprojecting coordinates."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["If you are using the Deck canvas as an ",(0,r.jsx)(n.a,{href:"../get-started/using-with-map",children:"overlay on a base map rendered by another library"}),", you may need to update the viewport using the API provided by that library rather than by deck.gl."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"types-of-views",children:"Types of Views"}),"\n",(0,r.jsxs)(n.p,{children:["deck.gl offers a set of ",(0,r.jsx)(n.code,{children:"View"})," classes that package the camera and controller logic that you need to visualize and interact with your data. You may choose one or multiple ",(0,r.jsx)(n.code,{children:"View"})," classes based on the type of data (e.g. geospatial, 2D chart) and the desired perspective (top down, first-person, etc)."]}),"\n",(0,r.jsx)(n.p,{children:"Note that the set of view state parameters that will be used varies between Views. Consult each view class' documentation for a full list of parameters supported."}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"View Class"}),(0,r.jsx)(n.th,{children:"Use Case"}),(0,r.jsx)(n.th,{children:"Status"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"/docs/api-reference/core/view",children:(0,r.jsx)(n.code,{children:"View"})})}),(0,r.jsx)(n.td,{}),(0,r.jsx)(n.td,{}),(0,r.jsxs)(n.td,{children:["The base view has to be supplied with raw view and projection matrices. It is typically only instantiated directly if the application needs to work with views that have been supplied from external sources, such as the ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API",children:"WebVR API"}),"."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.a,{href:"/docs/api-reference/core/map-view",children:(0,r.jsx)(n.code,{children:"MapView"})})," (default)"]}),(0,r.jsx)(n.td,{children:"geospatial"}),(0,r.jsx)(n.td,{children:"full support"}),(0,r.jsxs)(n.td,{children:["This view renders data using the ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Web_Mercator_projection",children:"Web Mercator projection"})," and is designed to match an external base map library such as Mapbox or Google Maps."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"/docs/api-reference/core/globe-view",children:(0,r.jsx)(n.code,{children:"GlobeView"})})}),(0,r.jsx)(n.td,{children:"geospatial"}),(0,r.jsx)(n.td,{children:"experimental"}),(0,r.jsx)(n.td,{children:"This view renders data as a 3D globe."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"/docs/api-reference/core/first-person-view",children:(0,r.jsx)(n.code,{children:"FirstPersonView"})})}),(0,r.jsx)(n.td,{children:"geospatial"}),(0,r.jsx)(n.td,{children:"full support"}),(0,r.jsxs)(n.td,{children:["The camera is positioned in a provided geolocation and looks in a provided direction, similar to that of a ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/First-person_(gaming)",children:"first-person game"}),"."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"/docs/api-reference/core/orthographic-view",children:(0,r.jsx)(n.code,{children:"OrthographicView"})})}),(0,r.jsx)(n.td,{children:"info-vis (2D)"}),(0,r.jsx)(n.td,{children:"full support"}),(0,r.jsx)(n.td,{children:"The camera looks at a target point from top-down. Does not rotate."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"/docs/api-reference/core/orbit-view",children:(0,r.jsx)(n.code,{children:"OrbitView"})})}),(0,r.jsx)(n.td,{children:"info-vis (3D)"}),(0,r.jsx)(n.td,{children:"full support"}),(0,r.jsx)(n.td,{children:"The camera looks at a target point from a provided direction. Rotates around the target."})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(n.h3,{id:"using-a-view",children:"Using a View"}),"\n",(0,r.jsxs)(n.p,{children:["If the ",(0,r.jsx)(n.code,{children:"views"})," prop of ",(0,r.jsx)(n.code,{children:"Deck"})," is not specified, deck.gl will automatically create a ",(0,r.jsx)(n.code,{children:"MapView"})," that fills the whole canvas, so basic geospatial applications often do not have to specify any ",(0,r.jsx)(n.code,{children:"View"}),"s."]}),"\n",(0,r.jsx)(n.p,{children:"If using non-geospatial data, you will need to manually create a view that is appropriate for info-vis, e.g.:"}),"\n","\n",(0,r.jsxs)(s.A,{groupId:"language",children:[(0,r.jsx)(o.A,{value:"js",label:"JavaScript",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import {Deck, OrthographicView} from '@deck.gl/core';\n\nconst deck = new Deck({\n  // ...\n  views: new OrthographicView()\n});\n"})})}),(0,r.jsx)(o.A,{value:"ts",label:"TypeScript",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {Deck, OrthographicView} from '@deck.gl/core';\n\nconst deck = new Deck({\n  // ...\n  views: new OrthographicView()\n});\n"})})}),(0,r.jsx)(o.A,{value:"react",label:"React",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import React from 'react';\nimport {DeckGL} from '@deck.gl/react';\nimport {OrthographicView} from '@deck.gl/core';\n\nfunction App() {\n  return <DeckGL\n    // ...\n    views={new OrthographicView()}\n  />;\n}\n"})})})]}),"\n",(0,r.jsx)(n.h3,{id:"using-a-view-with-view-state",children:"Using a View with View State"}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"initialViewState"}),' is provided, deck.gl automatically tracks the view states of interactive views (used as a "stateful" component):']}),"\n",(0,r.jsxs)(s.A,{groupId:"language",children:[(0,r.jsx)(o.A,{value:"js",label:"JavaScript",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import {Deck} from '@deck.gl/core';\n\nconst INITIAL_VIEW_STATE = {\n  longitude: -122.4,\n  latitude: 37.8,\n  zoom: 12,\n  pitch: 0,\n  bearing: 0\n};\n\nconst deckInstance = new Deck({\n  initialViewState: INITIAL_VIEW_STATE,\n  controller: true\n});\n"})})}),(0,r.jsx)(o.A,{value:"ts",label:"TypeScript",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {Deck, MapViewState} from '@deck.gl/core';\n\nconst INITIAL_VIEW_STATE: MapViewState = {\n  longitude: -122.4,\n  latitude: 37.8,\n  zoom: 12,\n  pitch: 0,\n  bearing: 0\n};\n\nconst deckInstance = new Deck({\n  initialViewState: INITIAL_VIEW_STATE,\n  controller: true\n});\n"})})}),(0,r.jsx)(o.A,{value:"react",label:"React",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import React from 'react';\nimport {DeckGL} from '@deck.gl/react';\nimport {MapViewState} from '@deck.gl/core';\n\nconst INITIAL_VIEW_STATE: MapViewState = {\n  longitude: -122.4,\n  latitude: 37.8,\n  zoom: 12,\n  pitch: 0,\n  bearing: 0\n};\n\nfunction App() {\n  return <DeckGL\n    initialViewState={INITIAL_VIEW_STATE}\n    controller\n  />;\n}\n"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["If you need to manage and manipulate the view state outside of deck.gl, you may do so by providing the ",(0,r.jsx)(n.code,{children:"viewState"}),' prop (used as a "stateless" component). In this case, you also need to listen to the ',(0,r.jsx)(n.code,{children:"onViewStateChange"})," callback and update the ",(0,r.jsx)(n.code,{children:"viewState"})," object yourself:"]}),"\n",(0,r.jsxs)(s.A,{groupId:"language",children:[(0,r.jsx)(o.A,{value:"js",label:"JavaScript",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import {Deck, OrthographicView} from '@deck.gl/core';\n\nconst INITIAL_VIEW_STATE = {\n  target: [0, 0, 0],\n  zoom: 1\n};\n\nconst deckInstance = new Deck({\n  viewState: INITIAL_VIEW_STATE,\n  controller: true,\n  onViewStateChange: e => {\n    deckInstance.setProps({\n      viewState: e.viewState\n    });\n  }\n});\n\ndocument.getElementById('reset-btn').onclick = () => {\n  deckInstance.setProps({\n    viewState: INITIAL_VIEW_STATE\n  });\n}\n"})})}),(0,r.jsx)(o.A,{value:"ts",label:"TypeScript",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {Deck, OrthographicView, OrthographicViewState} from '@deck.gl/core';\n\nconst INITIAL_VIEW_STATE: OrthographicViewState = {\n  target: [0, 0, 0],\n  zoom: 1\n};\n\nconst deckInstance = new Deck<OrthographicView>({\n  viewState: INITIAL_VIEW_STATE,\n  controller: true,\n  onViewStateChange: e => {\n    deckInstance.setProps({\n      viewState: e.viewState\n    });\n  }\n});\n\ndocument.getElementById('reset-btn').onclick = () => {\n  deckInstance.setProps({\n    viewState: INITIAL_VIEW_STATE\n  });\n}\n"})})}),(0,r.jsx)(o.A,{value:"react",label:"React",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import React, {useState, useCallback} from 'react';\nimport {DeckGL} from '@deck.gl/react';\nimport {OrthographicView, OrthographicViewState} from '@deck.gl/core';\n\nconst INITIAL_VIEW_STATE: OrthographicViewState = {\n  target: [0, 0, 0],\n  zoom: 1\n};\n\nfunction App() {\n  const [viewState, setViewState] = useState<OrthographicViewState>(INITIAL_VIEW_STATE);\n\n  const onReset = useCallback(() => setViewState(INITIAL_VIEW_STATE), []);\n\n  return <>\n    <DeckGL\n      views={new OrthographicView()}\n      controller\n      viewState={viewState}\n      onViewStateChange={e => setViewState(e.viewState)}\n    />\n    <button onClick={onReset}>Reset</button>\n  </>;\n}\n"})})})]}),"\n",(0,r.jsx)(n.h3,{id:"using-multiple-views",children:"Using Multiple Views"}),"\n",(0,r.jsxs)(n.p,{children:["deck.gl also supports multiple views by taking a ",(0,r.jsx)(n.code,{children:"views"})," prop that is a list of ",(0,r.jsx)(n.code,{children:"View"})," instances."]}),"\n",(0,r.jsxs)(n.p,{children:["Views allow the application to specify the position and extent of the viewport (i.e. the target rendering area on the screen) with ",(0,r.jsx)(n.code,{children:"x"})," (left), ",(0,r.jsx)(n.code,{children:"y"})," (top), ",(0,r.jsx)(n.code,{children:"width"})," and ",(0,r.jsx)(n.code,{children:"height"}),". These can be specified in either numbers or CSS-like percentage strings (e.g. ",(0,r.jsx)(n.code,{children:"width: '50%'"}),"), which is evaluated at runtime when the canvas resizes."]}),"\n",(0,r.jsx)(n.p,{children:'Common examples in 3D applications that render a 3D scene multiple times with different "cameras":'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"To show views from multiple viewpoints (cameras), e.g. in a split screen setup."}),"\n",(0,r.jsx)(n.li,{children:'To show a detail view (e.g, first person), and an overlaid, smaller "map" view (e.g. third person or top down, zoomed out to show where the primary viewpoint is).'}),"\n",(0,r.jsx)(n.li,{children:"To support stereoscopic rendering (e.g. VR), where left and right views are needed, providing the necessary parallax between left and right eye."}),"\n",(0,r.jsx)(n.li,{children:"For rendering into offscreen framebuffers, which can then be used for e.g. advanced visual effects, screen shot solutions, overlays onto DOM elements outside of the primary deck.gl canvas (e.g. a video)."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Example of displaying two maps side-by-side, and any camera change in one map is synchronized to another:"}),"\n",(0,r.jsxs)(s.A,{groupId:"language",children:[(0,r.jsx)(o.A,{value:"js",label:"JavaScript",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import {Deck, MapView} from '@deck.gl/core';\n\nconst deckInstance = new Deck({\n  views: [\n    new MapView({id: 'left', x: 0, width: '50%', controller: true}),\n    new MapView({id: 'right', x: '50%', width: '50%', controller: true})\n  ],\n  viewState: {\n    longitude: -122.4,\n    latitude: 37.8,\n    zoom: 12\n  },\n  onViewStateChange: ({viewState}) => {\n    deckInstance.setProps({viewState});\n  }\n});\n"})})}),(0,r.jsx)(o.A,{value:"ts",label:"TypeScript",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {Deck, MapView} from '@deck.gl/core';\n\nconst deckInstance = new Deck<[MapView, MapView]>({\n  views: [\n    new MapView({id: 'left', x: 0, width: '50%', controller: true}),\n    new MapView({id: 'right', x: '50%', width: '50%', controller: true})\n  ],\n  viewState: {\n    longitude: -122.4,\n    latitude: 37.8,\n    zoom: 12\n  },\n  onViewStateChange: ({viewState}) => {\n    deckInstance.setProps({viewState});\n  }\n});\n"})})}),(0,r.jsx)(o.A,{value:"react",label:"React",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import React, {useState} from 'react';\nimport {DeckGL} from '@deck.gl/react';\nimport {MapView, MapViewState} from '@deck.gl/core';\n\nfunction App() {\n  const [viewState, setViewState] = useState<MapViewState>({\n    longitude: -122.4,\n    latitude: 37.8,\n    zoom: 12\n  });\n\n  return <DeckGL\n    views={[\n      new MapView({id: 'left', x: 0, width: '50%', controller: true}),\n      new MapView({id: 'right', x: '50%', width: '50%', controller: true})\n    ]}\n    viewState={viewState}\n    onViewStateChange={evt => setViewState(evt.viewState)}\n  />;\n}\n"})})})]}),"\n",(0,r.jsx)(n.h3,{id:"using-multiple-views-with-view-states",children:"Using Multiple Views with View States"}),"\n",(0,r.jsxs)(n.p,{children:["When using multiple views, each ",(0,r.jsx)(n.code,{children:"View"})," can either have its own independent view state, or share the same view state as other views. To define the view state of a specific view, add a key to the ",(0,r.jsx)(n.code,{children:"viewState"})," object that matches its view id."]}),"\n",(0,r.jsx)(n.p,{children:'The following example displays a "minimap" in the corner that synchronizes with the main view, but provides a different perspective:'}),"\n",(0,r.jsxs)(s.A,{groupId:"language",children:[(0,r.jsx)(o.A,{value:"js",label:"JavaScript",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import {Deck, MapView} from '@deck.gl/core';\n\nlet currentViewState = {\n  main: {\n    longitude: -122.4,\n    latitude: 37.8,\n    pitch: 30,\n    zoom: 12,\n  },\n  minimap: {\n    longitude: -122.4,\n    latitude: 37.8,\n    zoom: 8\n  }\n};\n\nfunction onViewStateChange({viewId, viewState}) {\n  if (viewId === 'main') {\n    // When user moves the camera in the first-person view, the minimap should follow\n    currentViewState = {\n      main: viewState,\n      minimap: {\n        ...currentViewStates.minimap,\n        longitude: viewState.longitude,\n        latitude: viewState.latitude\n      }\n    };\n  } else {\n    // Only allow the user to change the zoom in the minimap\n    currentViewState = {\n      main: currentViewStates.main,\n      minimap: {\n        ...currentViewStates.minimap,\n        zoom: viewState.zoom\n      }\n    };\n  }\n  // Apply the new view state\n  deckInstance.setProps({viewState: currentViewState});\n};\n\nconst deckInstance = new Deck({\n  views: [\n    new MapView({id: 'main', controller: true}),\n    new MapView({id: 'minimap', x: 10, y: 10, width: 300, height: 200, controller: true})\n  ],\n  viewState: currentViewState\n  onViewStateChange\n});\n"})})}),(0,r.jsx)(o.A,{value:"ts",label:"TypeScript",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {Deck, MapView, MapViewState} from '@deck.gl/core';\n\nlet currentViewState: {\n  main: MapViewState;\n  minimap: MapViewState\n} = {\n  main: {\n    longitude: -122.4,\n    latitude: 37.8,\n    pitch: 30,\n    zoom: 12,\n  },\n  minimap: {\n    longitude: -122.4,\n    latitude: 37.8,\n    zoom: 8\n  }\n};\n\nfunction onViewStateChange({viewId, viewState}: {\n  viewId: 'main' | 'minimap';\n  viewState: MapViewState;\n}) {\n  if (viewId === 'main') {\n    // When user moves the camera in the first-person view, the minimap should follow\n    currentViewState = {\n      main: viewState,\n      minimap: {\n        ...currentViewStates.minimap,\n        longitude: viewState.longitude,\n        latitude: viewState.latitude\n      }\n    };\n  } else {\n    // Only allow the user to change the zoom in the minimap\n    currentViewState = {\n      main: currentViewStates.main,\n      minimap: {\n        ...currentViewStates.minimap,\n        zoom: viewState.zoom\n      }\n    };\n  }\n  // Apply the new view state\n  deckInstance.setProps({viewState: currentViewState});\n};\n\nconst deckInstance = new Deck<[MapView, MapView]>({\n  views: [\n    new MapView({id: 'main', controller: true}),\n    new MapView({id: 'minimap', x: 10, y: 10, width: 300, height: 200, controller: true})\n  ],\n  viewState: currentViewState\n  onViewStateChange\n});\n"})})}),(0,r.jsx)(o.A,{value:"react",label:"React",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import React, {useState, useCallback} from 'react';\nimport {DeckGL} from '@deck.gl/react';\nimport {MapView, MapViewState} from '@deck.gl/core';\n\nfunction App() {\n  const [viewStates, setViewStates] = useState<{\n    main: MapViewState;\n    minimap: MapViewState\n  }>({\n    main: {\n      longitude: -122.4,\n      latitude: 37.8,\n      pitch: 30,\n      zoom: 12,\n    },\n    minimap: {\n      longitude: -122.4,\n      latitude: 37.8,\n      zoom: 8\n    }\n  });\n\n  const onViewStateChange = useCallback(({viewId, viewState}: {\n    viewId: 'main' | 'minimap';\n    viewState: MapViewState;\n  }) => {\n    if (viewId === 'main') {\n      // When user moves the camera in the first-person view, the minimap should follow\n      setViewStates(currentViewStates => ({\n        main: viewState,\n        minimap: {\n          ...currentViewStates.minimap,\n          longitude: viewState.longitude,\n          latitude: viewState.latitude\n        }\n      }));\n    } else {\n      // Only allow the user to change the zoom in the minimap\n      setViewStates(currentViewStates => ({\n        main: currentViewStates.main,\n        minimap: {\n          ...currentViewStates.minimap,\n          zoom: viewState.zoom\n        }\n      }));\n    }\n  }, []);\n\n  render() {\n    return <DeckGL\n      views={[\n        new MapView({id: 'main', controller: true}),\n        new MapView({id: 'minimap', x: 10, y: 10, width: 300, height: 200, controller: true})\n      ]}\n      viewState={viewStates}\n      onViewStateChange={onViewStateChange}\n    />;\n  }\n}\n"})})})]}),"\n",(0,r.jsx)(n.h3,{id:"rendering-layers-in-multiple-views",children:"Rendering Layers in Multiple Views"}),"\n",(0,r.jsx)(n.p,{children:"By default, all visible layers are rendered into all the views. This may not be the case if certain layers are designed to go into one particular view."}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Deck"})," class has a ",(0,r.jsx)(n.code,{children:"layerFilter"})," prop that can be used to determine which layers to draw in which view. In the following example, two views are rendered to follow a car moving on a map: a first-person perspective from the car's dash, and a top-down perspective of the city block that it's in. We only want to render the 3D car model in the minimap because it would block the camera in the first-person view."]}),"\n",(0,r.jsxs)(s.A,{groupId:"language",children:[(0,r.jsx)(o.A,{value:"js",label:"JavaScript",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import {Deck, FirstPersonView, MapView} from '@deck.gl/core';\nimport {SimpleMeshLayer} from '@deck.gl/mesh-layers';\nimport {MVTLayer} from '@deck.gl/geo-layers';\n\nconst deckInstance = new Deck({\n  views: [\n    new FirstPersonView({id: 'first-person'}),\n    new MapView({id: 'minimap', x: 10, y: 10, width: '20%', height: '20%'})\n  ],\n  layerFilter: ({layer, viewport}) => {\n    if (viewport.id === 'first-person' && layer.id === 'car') {\n      // Do not draw the car layer in the first person view\n      return false;\n    }\n    return true;\n  }\n});\n\n/** Called periodically to update the map with the car's latest position */\nfunction updateCar(carPose) {\n  deckInstance.setProps({\n    layers: [\n      new MVTLayer({\n        id: 'base-map',\n        // ...\n      }),\n      new SimpleMeshLayer({\n        id: 'car',\n        mesh: '/path/to/model.obj',\n        data: [carPose],\n        getPosition: d => [d.longitude, d.latitude, 0],\n        getOrientation: d => [0, -d.heading * Math.PI / 180, 0]\n      })\n    ],\n    viewState: {\n      'first-person': {\n        longitude: carPos.longitude,\n        latitude: carPos.latitude,\n        bearing: carPos.heading,\n        position: [0, 0, 2]\n      },\n      minimap: {\n        longitude: carPos.longitude,\n        latitude: carPos.latitude,\n        zoom: 10\n      }\n    }\n  });\n}\n"})})}),(0,r.jsx)(o.A,{value:"ts",label:"TypeScript",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {Deck, FirstPersonView, MapView} from '@deck.gl/core';\nimport {SimpleMeshLayer} from '@deck.gl/mesh-layers';\nimport {MVTLayer} from '@deck.gl/geo-layers';\n\ntype CarPose = {\n  longitude: number;\n  latitude: number;\n  heading: number;\n};\n\nconst deckInstance = new Deck<[FirstPersonView, MapView]>({\n  views: [\n    new FirstPersonView({id: 'first-person'}),\n    new MapView({id: 'minimap', x: 10, y: 10, width: '20%', height: '20%'})\n  ],\n  layerFilter: ({layer, viewport}) => {\n    if (viewport.id === 'first-person' && layer.id === 'car') {\n      // Do not draw the car layer in the first person view\n      return false;\n    }\n    return true;\n  }\n});\n\n/** Called periodically to update the map with the car's latest position */\nfunction updateCar(carPose: CarPos) {\n  deckInstance.setProps({\n    layers: [\n      new MVTLayer({\n        id: 'base-map',\n        // ...\n      }),\n      new SimpleMeshLayer<CarPose>({\n        id: 'car',\n        mesh: '/path/to/model.obj',\n        data: [carPose],\n        getPosition: (d: CarPose) => [d.longitude, d.latitude, 0],\n        getOrientation: (d: CarPos) => [0, -d.heading * Math.PI / 180, 0]\n      })\n    ],\n    viewState: {\n      'first-person': {\n        longitude: carPos.longitude,\n        latitude: carPos.latitude,\n        bearing: carPos.heading,\n        position: [0, 0, 2]\n      },\n      minimap: {\n        longitude: carPos.longitude,\n        latitude: carPos.latitude,\n        zoom: 10\n      }\n    }\n  });\n}\n"})})}),(0,r.jsx)(o.A,{value:"react",label:"React",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import React, {useMemo, useCallback} from 'react';\nimport {DeckGL} from '@deck.gl/react';\nimport {Deck, DeckProps, FirstPersonView, MapView} from '@deck.gl/core';\nimport {SimpleMeshLayer} from '@deck.gl/mesh-layers';\nimport {MVTLayer} from '@deck.gl/geo-layers';\n\ntype CarPose = {\n  longitude: number;\n  latitude: number;\n  heading: number;\n};\n\n/** Rerenders periodically to update the map with the car's latest position */\nfunction App({carPose}: {\n  carPos: CarPose;\n}) {\n\n  const layers = useMemo(() => [\n    new MVTLayer({\n      id: 'base-map',\n      // ...\n    }),\n    new SimpleMeshLayer<CarPose>({\n      id: 'car',\n      mesh: '/path/to/model.obj',\n      data: [carPose],\n      getPosition: (d: CarPose) => [d.longitude, d.latitude, 0],\n      getOrientation: (d: CarPos) => [0, -d.heading * Math.PI / 180, 0]\n    })\n  ], [carPos]);\n\n  const views = useMemo(() => [\n    new FirstPersonView({id: 'first-person'}),\n    new MapView({id: 'minimap', x: 10, y: 10, width: '20%', height: '20%'})\n  ], []);\n\n  const layerFilter: DeckProps[\"layerFilter\"] = useCallback(({layer, viewport}) => {\n    if (viewport.id === 'first-person' && layer.id === 'car') {\n      // Do not draw the car layer in the first person view\n      return false;\n    }\n    return true;\n  }, []);\n\n  return <DeckGL\n    views={views}\n    viewState={{\n      'first-person': {\n        longitude: carPos.longitude,\n        latitude: carPos.latitude,\n        bearing: carPos.heading,\n        position: [0, 0, 2]\n      },\n      minimap: {\n        longitude: carPos.longitude,\n        latitude: carPos.latitude,\n        zoom: 10\n      }\n    }}\n    layers={layers}\n    layerFilter={layerFilter}\n  />;\n}\n"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["Some layers, including ",(0,r.jsx)(n.code,{children:"TileLayer"}),", ",(0,r.jsx)(n.code,{children:"MVTLayer"}),", ",(0,r.jsx)(n.code,{children:"HeatmapLayer"})," and ",(0,r.jsx)(n.code,{children:"ScreenGridLayer"}),", perform expensive operations (data fetching and/or aggregation) on viewport change. Therefore, it is generally ",(0,r.jsx)(n.em,{children:"NOT"})," recommended to render them into multiple views. If you do need to show e.g. tiled base map in multiple views, create one layer instance for each view and limit their rendering with ",(0,r.jsx)(n.code,{children:"layerFilter"}),":"]}),"\n",(0,r.jsxs)(s.A,{groupId:"language",children:[(0,r.jsx)(o.A,{value:"js",label:"JavaScript",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import {Deck, MapView} from '@deck.gl/core';\nimport {MVTLayer} from '@deck.gl/geo-layers';\n\nconst deck = new Deck({\n  // ...\n  views: [\n    new MapView({id: 'main', controller: true}),\n    new MapView({id: 'minimap', x: 10, y: 10, width: 300, height: 200})\n  ],\n  layers: [\n    new MVTLayer({\n      id: 'tiles-for-main',\n      // ...\n    }),\n    new MVTLayer({\n      id: 'tiles-for-minimap',\n      // ...\n    })\n  ],\n  layerFilter: ({layer, viewport}) => {\n    return layer.id === `tiles-for-${viewport.id}`;\n  }\n});\n"})})}),(0,r.jsx)(o.A,{value:"ts",label:"TypeScript",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {Deck, MapView} from '@deck.gl/core';\nimport {MVTLayer} from '@deck.gl/geo-layers';\n\nconst deck = new Deck<[MapView, MapView]>({\n  // ...\n  views: [\n    new MapView({id: 'main', controller: true}),\n    new MapView({id: 'minimap', x: 10, y: 10, width: 300, height: 200})\n  ],\n  layers: [\n    new MVTLayer({\n      id: 'tiles-for-main',\n      // ...\n    }),\n    new MVTLayer({\n      id: 'tiles-for-minimap',\n      // ...\n    })\n  ],\n  layerFilter: ({layer, viewport}) => {\n    return layer.id === `tiles-for-${viewport.id}`;\n  }\n});\n"})})}),(0,r.jsx)(o.A,{value:"react",label:"React",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import React, {useMemo, useCallback} from 'react';\nimport {DeckGL} from '@deck.gl/react';\nimport {DeckProps, MapView} from '@deck.gl/core';\nimport {MVTLayer} from '@deck.gl/geo-layers';\n\nfunction App() {\n  const views = useMemo(() => [\n    new MapView({id: 'main', controller: true}),\n    new MapView({id: 'minimap', x: 10, y: 10, width: 300, height: 200})\n  ], []);\n\n  const layers = useMemo(() => [\n    new MVTLayer({\n      id: 'tiles-for-main',\n      // ...\n    }),\n    new MVTLayer({\n      id: 'tiles-for-minimap',\n      // ...\n    })\n  ], []);\n\n  const layerFilter: DeckProps[\"layerFilter\"] = useCallback(({layer, viewport} => {\n    return layer.id === `tiles-for-${viewport.id}`;\n  }), []);\n\n  return <DeckGL\n    // ...\n    views={views}\n    layers={layers}\n    layerFilter={layerFilter}\n  />;\n}\n"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["Starting with v8.5, ",(0,r.jsx)(n.code,{children:"Tile3DLayer"})," supports rendering in multiple views with a single tile cache."]}),"\n",(0,r.jsx)(n.h3,{id:"picking-in-multiple-views",children:"Picking in Multiple Views"}),"\n",(0,r.jsx)(n.p,{children:"deck.gl's built-in picking support extends naturally to multiple viewports. The picking process renders all viewports."}),"\n",(0,r.jsxs)(n.p,{children:["Note that the ",(0,r.jsx)(n.code,{children:"pickInfo"})," object does not contain a viewport reference, so you will not be able to tell which viewport was used to pick an object."]}),"\n",(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.a,{href:"#rendering-layers-in-multiple-views",children:"above example"}),", you may also control which layer is pickable by view in ",(0,r.jsx)(n.code,{children:"layerFilter"}),":"]}),"\n",(0,r.jsxs)(s.A,{groupId:"language",children:[(0,r.jsx)(o.A,{value:"js",label:"JavaScript",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const layerFilter = ({layer, viewport, isPicking}) => {\n  if (viewport.id === 'first-person' && layer.id === 'car') {\n    // Do not draw the car layer in the first person view\n    return false;\n  }\n  if (isPicking && viewport.id === 'minimap') {\n    // Do not pick anything in the minimap\n    return false;\n  }\n  return true;\n};\n"})})}),(0,r.jsx)(o.A,{value:"ts",label:"TypeScript",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const layerFilter: DeckProps[\"layerFilter\"] = ({layer, viewport, isPicking}) => {\n  if (viewport.id === 'first-person' && layer.id === 'car') {\n    // Do not draw the car layer in the first person view\n    return false;\n  }\n  if (isPicking && viewport.id === 'minimap') {\n    // Do not pick anything in the minimap\n    return false;\n  }\n  return true;\n};\n"})})}),(0,r.jsx)(o.A,{value:"react",label:"React",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"const layerFilter: DeckProps[\"layerFilter\"] = useCallback(({layer, viewport, isPicking}) => {\n  if (viewport.id === 'first-person' && layer.id === 'car') {\n    // Do not draw the car layer in the first person view\n    return false;\n  }\n  if (isPicking && viewport.id === 'minimap') {\n    // Do not pick anything in the minimap\n    return false;\n  }\n  return true;\n}, []);\n"})})})]}),"\n",(0,r.jsx)(n.h3,{id:"auto-positioning-ui-components-behind-views",children:"Auto-Positioning UI Components Behind Views"}),"\n",(0,r.jsxs)(n.p,{children:["When the deck.gl project first started, one of our major use cases was to build complex Web apps with perfectly synchronized WebGL visualizations and other UI components (HTML markers, charts, lists, etc.). Given the scale of these applications, some reactive, virtual-DOM framework is expected to be in use. At the moment, these features are only implemented for React. Visit the ",(0,r.jsx)(n.a,{href:"/docs/api-reference/react/deckgl",children:"DeckGL React component"})," docs for examples."]}),"\n",(0,r.jsx)(n.h2,{id:"performance-notes",children:"Performance Notes"}),"\n",(0,r.jsxs)(n.p,{children:["This section discusses how ",(0,r.jsx)(n.code,{children:"views"})," and ",(0,r.jsx)(n.code,{children:"viewState"})," impacts performance (frame rate)."]}),"\n",(0,r.jsxs)(n.p,{children:["Between rerenders, the ",(0,r.jsx)(n.code,{children:"views"})," and ",(0,r.jsx)(n.code,{children:"viewState"})," props are deep compared to determine if anything changed. There is very little performance concern even if new view instances are constructed each render, as long as they are deemed equivalent with the previous values."]}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"views"}),"/",(0,r.jsx)(n.code,{children:"viewState"})," do change, new viewports will be constructed. At this point, two things will happen:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Layers are given a chance to recompute their state and create additional GPU resources (by calling the ",(0,r.jsx)(n.code,{children:"shouldUpdateState"})," lifecycle method), with the ",(0,r.jsx)(n.code,{children:"UpdateParameters"})," argument containing ",(0,r.jsx)(n.code,{children:"changeFlags.viewportChanged: true"}),". By default, most layers ignore viewport changes, so ",(0,r.jsx)(n.code,{children:"updateState"})," does not get called as long as nothing else changes. However, some layers do need to update when viewport changes (e.g. the ",(0,r.jsx)(n.a,{href:"/docs/api-reference/geo-layers/tile-layer",children:"TileLayer"})," and ",(0,r.jsx)(n.a,{href:"/docs/api-reference/aggregation-layers/heatmap-layer",children:"HeatmapLayer"}),"). During interaction and transition, this may happen many times a second, so such layers may contribute to significant performance overhead."]}),"\n",(0,r.jsx)(n.li,{children:"Afterwards, all layers are redrawn to the updated viewport. This is a relatively cheap step as GPU is doing the heavy-lifting. All that CPU has to do is to supply the GPU with the new viewport parameters."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Read more about this topic in ",(0,r.jsx)(n.a,{href:"/docs/developer-guide/custom-layers/layer-lifecycle",children:"Layer Lifecycles"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},19365:(e,n,t)=>{t.d(n,{A:()=>s});t(96540);var i=t(34164);const r={tabItem:"tabItem_Ymn6"};var a=t(74848);function s(e){let{children:n,hidden:t,className:s}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,i.A)(r.tabItem,s),hidden:t,children:n})}},11470:(e,n,t)=>{t.d(n,{A:()=>b});var i=t(96540),r=t(34164),a=t(23104),s=t(56347),o=t(205),l=t(57485),c=t(31682),d=t(70679);function h(e){var n,t;return null!=(n=null==(t=i.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}function p(e){const{values:n,children:t}=e;return(0,i.useMemo)((()=>{const e=null!=n?n:function(e){return h(e).map((e=>{let{props:{value:n,label:t,attributes:i,default:r}}=e;return{value:n,label:t,attributes:i,default:r}}))}(t);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function u(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function w(e){let{queryString:n=!1,groupId:t}=e;const r=(0,s.W6)(),a=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,l.aZ)(a),(0,i.useCallback)((e=>{if(!a)return;const n=new URLSearchParams(r.location.search);n.set(a,e),r.replace(Object.assign({},r.location,{search:n.toString()}))}),[a,r])]}function m(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,a=p(e),[s,l]=(0,i.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:i}=e;if(0===i.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!u({value:t,tabValues:i}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+i.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const r=null!=(n=i.find((e=>e.default)))?n:i[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:a}))),[c,h]=w({queryString:t,groupId:r}),[m,g]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[r,a]=(0,d.Dv)(t);return[r,(0,i.useCallback)((e=>{t&&a.set(e)}),[t,a])]}({groupId:r}),v=(()=>{const e=null!=c?c:m;return u({value:e,tabValues:a})?e:null})();(0,o.A)((()=>{v&&l(v)}),[v]);return{selectedValue:s,selectValue:(0,i.useCallback)((e=>{if(!u({value:e,tabValues:a}))throw new Error("Can't select invalid tab value="+e);l(e),h(e),g(e)}),[h,g,a]),tabValues:a}}var g=t(92303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=t(74848);function j(e){let{className:n,block:t,selectedValue:i,selectValue:s,tabValues:o}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,a.a_)(),d=e=>{const n=e.currentTarget,t=l.indexOf(n),r=o[t].value;r!==i&&(c(n),s(r))},h=e=>{var n;let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{var i;const n=l.indexOf(e.currentTarget)+1;t=null!=(i=l[n])?i:l[0];break}case"ArrowLeft":{var r;const n=l.indexOf(e.currentTarget)-1;t=null!=(r=l[n])?r:l[l.length-1];break}}null==(n=t)||n.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:o.map((e=>{let{value:n,label:t,attributes:a}=e;return(0,f.jsx)("li",Object.assign({role:"tab",tabIndex:i===n?0:-1,"aria-selected":i===n,ref:e=>l.push(e),onKeyDown:h,onClick:d},a,{className:(0,r.A)("tabs__item",v.tabItem,null==a?void 0:a.className,{"tabs__item--active":i===n}),children:null!=t?t:n}),n)}))})}function x(e){let{lazy:n,children:t,selectedValue:a}=e;const s=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=s.find((e=>e.props.value===a));return e?(0,i.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:s.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==a})))})}function y(e){const n=m(e);return(0,f.jsxs)("div",{className:(0,r.A)("tabs-container",v.tabList),children:[(0,f.jsx)(j,Object.assign({},n,e)),(0,f.jsx)(x,Object.assign({},n,e))]})}function b(e){const n=(0,g.A)();return(0,f.jsx)(y,Object.assign({},e,{children:h(e.children)}),String(n))}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var i=t(96540);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);